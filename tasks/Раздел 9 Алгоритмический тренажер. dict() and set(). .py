# - 1 - Напишите инструкцию, которая создает словарь, содержащий приведенные ниже пары
#       ключ/значение:
#   'а' 1
#   'б' : 2
#   'в' : 3
# Решение :
# dict_1 = {'a': 1, 'b': 2, 'c': 3}

# - 2 - Напишите инструкцию, которая создает пустой словарь.
# Решение :
# set_1 = set(); set_1 = {}

# - 3 - Предположим, что переменная dct ссылается на словарь. Напишите инструкцию if, которая
#       определяет, существует ли в словаре ключ 'Джеймс'. Если да, то покажите значение,
#       которое связано с этим ключом. Если ключа в словаре нет, то покажите соответствующее сообщение.
# Решение :
# dct = {'Джеймс': 123, 'Lusi': 321}
# if 'Джеймс' in dct:
#     print(dct['Джеймс'])

# - 4 - Предположим, что переменная dct ссылается на словарь. Напишите инструкцию if,
#       которая определяет, существует ли в словаре ключ 'Джим'. Если да, то удалите ключ
#       'Джим' и связанное с ним значение.
# Решение :
# dct = {'Джеймс': 123, 'Lusi': 321, 'Jim': 456}
# if 'Jim' in dct:
#     dct.pop('Jim')
#     print(dct)

# - 5 - Напишите фрагмент кода, который создает множество с приведенными далее целыми
#       числами в качестве его членов: 1О, 20, 30 и 40.
# Решение :
# dct = {10, 20, 30, 40}

# - 6 - Допустим, что обе переменные set1 и set2 ссылаются на множество. Напишите фрагмент
#   кода, который создает еще одно множество, содержащее все элементы из set1 и
#   set2, и присваивает получившееся множество переменной setЗ.
# Решение :
# dct_1 = {10, 20, 30, 40}
# dct_2 = {50, 60, 70, 80}
# dct_3 = dct_1.union(dct_2)
# print(dct_3)

# - 7 - Допустим, что обе переменные set1 и set2 ссылаются на множество. Напишите фрагмент
#       кода, который создает еще одно множество, содержащее только те элементы, которые
#       одновременно находятся в set1 и в set2, и присвойте получившееся множество переменной setЗ.
# Решение :
# dct_1 = {10, 20, 30, 50}
# dct_2 = {50, 10, 70, 80}
# dct_3 = dct_1 & dct_2
# print(dct_3)

# - 8 - Допустим, что обе переменные setl и set2 ссылаются на множество. Напишите фрагмент
#       кода, который создает еще одно множество, содержащее все элементы set1, не
#       входящие в set2, и присвойте получившееся множество переменной setЗ.
# Решение :
# dct_1 = {10, 20, 30, 50}
# dct_2 = {50, 10, 70, 80}
# dct_3 = dct_1 - dct_2
# print(dct_3)

# - 9 - Допустим, что обе переменные set1 и set2 ссылаются на множество. Напишите фрагмент
#       кода, который создает еще одно множество, содержащее все элементы set2, не
#       входящие в setl, и присвойте получившееся множество переменной setЗ.
# Решение :
# dct_1 = {10, 20, 30, 50}
# dct_2 = {50, 10, 70, 80}
# dct_3 = dct_2 - dct_1
# print(dct_3)

# - 1О - Допустим, что обе переменные setl и set2 ссылаются на множество. Напишите фрагмент
#        кода, который создает еще одно множество с элементами, не принадлежащими
#        одновременно setl и set2, и присвойте получившееся множество переменной setЗ.
# Решение :
# dct_1 = {10, 20, 30, 50}
# dct_2 = {50, 10, 70, 80}
# dct_3 = dct_1 ^ dct_2
# print(dct_3)

# - 11 - Предположим, что переменная dct ссылается на словарь. Напишите фрагмент кода, который
#        консервирует словарь и сохраняет его в файле mydata.dat.
# Решение :
# import pickle
# dict_1 = {'CS101': '3004', 'CS102': '4501', 'CS103': '6755', 'CS104': '1244', 'CS105': '1411'}
# mydata = open('dict_1.dat', 'wb')
# pickle.dump(dict_1, mydata)
# mydata.close()

# - 12 - Напишите фрагмент кода, который извлекает и расконсервирует словарь, законсервированный в задании 11.
# Решение :
# import pickle
# mydata = open('dict_1.dat', 'rb')
# pb = pickle.load(mydata)
# print(pb)


