# - 1 - Инициалы. Напишите программу, которая получает строковое значение, содержащее имя, отчество и
#       фамилию человека и показывает инициалы. Например, если пользователь вводит Михаил Иванович Кузнецов,
#       то программа должна вывести М.И.К.

# Решение:

# f_name = input('Enter f_name: ')[:1]
# m_name = input('Enter m_name: ')[:1]
# l_name = input('Enter l_name: ')[:1]
# print(f'{f_name}.{m_name}.{l_name}')

# - 2 - Сумма цифр в строке. Напишите программу, которая просит пользователя ввести ряд однозначных чисел без
#       разделителей. Программа должна вывести на экран сумму всех однозначных чисел в строковом значении.
#       Например, если пользователь вводит 2514, то этот метод должен вернуть значение 12, которое является суммой
#       2, 5, 1 и 4.

# Решение:
# Программа вычисляет сумму чисел которые записанны в ряд ДРУГ за ДРУГОМ без пробела.
# print(sum([int(i) for i in list(str(int(input(': '))))]))

# - 3-  Принтер дат. Напишите программу, которая считывает от пользователя строковое значение, содержащее дату в
#       формате дд/мм/гггг. Она должна напечатать дату в формате 12 марта 2018 г.

# Решение: хуй знает я понял так.....

# data = input('Enter dd: ')
# month = input('Enter month: ')
# year = input('Enter year: ')
# if month == '01':
#     print(f'{data} Января {year}')
# elif month == '02':
#     print(f'{data} Февраля {year}')
# elif month == '03':
#     print(f'{data} Марта {year}')
# elif month == '04':
#     print(f'{data} Апреля {year}')
# elif month == '05':
#     print(f'{data} Мая {year}')
# elif month == '06':
#     print(f'{data} Июня {year}')
# elif month == '07':
#     print(f'{data} Июля {year}')
# elif month == '08':
#     print(f'{data} Августа {year}')
# elif month == '09':
#     print(f'{data} Сентября {year}')
# elif month == '10':
#     print(f'{data} Октября {year}')
# elif month == '11':
#     print(f'{data} Ноября {year}')
# elif month == '12':
#     print(f'{data} Декабря {year}')

# - 4 - Конвертер азбуки Морзе. Азбука Морзе представляет собой кодировку, где каждая буква алфавита, каждая цифра и
#       различные знаки препинания представлены серией точек и тире. В табл. 8.4 и 8.5 показана часть этой азбуки.
#       Напишите программу, которая просит пользователя ввести строковое значение и затем преобразует это строковое
#       значение в кодировку азбукой Морзе.

# Решение 1:

# morza = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..',
#          'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
#          'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..',
#          '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
#          '8': '---..', '9': '----.', '0': '-----', ', ': '--..--', '.': '.-.-.-', '?': '..--..', ' ': ' '}
#
# for i in input(': ').split():
#     print(' '.join(morza[c] for c in i.upper()))
#
# result = dict([val, key] for key, val in morza.items())
# print(''.join([result[i] for i in input('>: ').split()]))


# Решение 2:

# for i in input(': ').split():
#     print(' '.join(map(lambda c: morza[c], i.upper())))


# - 5 - Алфавитный переводчик номера телефона. Многие компании используют телефонные номера наподобие 555-GET-FOOD,
#       чтобы клиентам было легче запоминать эти номера. На стандартном телефоне буквам алфавита поставлены в
#       соответствие числа следующим образом:
#       А,В и С=2; D,Е и F=З; G,Н и I=4; J,К и L=5; М,N и O=6; P,Q, R и S=7; Т, U и V=8; W,X, У и Z=9
#       Напишите программу, которая просит пользователя ввести 10-символьный номер телефона в формате ХХХ-ХХХ-ХХХХ.
#       Приложение должно показать номер телефона, в котором все буквенные символы в оригинале переведены в их числовой
#       эквивалент. Например, если пользователь вводит 555-GET-FOOD, то приложение должно вывести 555-438-3663.

# Решение:
# 1. В начале просто создаём словарь с значениями на каждую букву, и номер который мы с помощью метода "split("-")"
# переформатируем строку в список как будто разрезав её по символу "-" для дальнейшей расшифровки.

# 2.1. Потом создаём основную функцию расшифровки с одним аргументом строкового типа.

# 2.2. Теперь записываем в переменную с помощью цикла "for" перебирая все символы переданного аргумента в функцию,
# и если в перебираемом элементе цифра, то он просто записывает её в список, иначе он использует значение ключа из
# переменной с расшифровкой данных.

# 2.3. Заключением функции это перевод списка в строку с использованием метода "join", и возвращая получившийся
# результат.

# 3. В проверке "if __name__ == '__main__':" мы запускаем основной код программы в случае если программа запущена как
# основной файл, а не как импортируемый модуль.

# 4. Далее мы записываем в переменную с помощью генератора списков перебирая и отбирая строки в списке с нашим номером
# которые состоят только из букв, вызывая функцию которую мы делали на шаге "2", тем самым получая строки с уже
# расшифрованными строками.

# 5. В конце мы переводим список в строку разделяя все объекты символом "-" с помощью метода "join", и выводим
# результат на экран.

# code, number = {
#                    "A": "2", "B": "2", "C": "2", "D": "3", "E": "3", "F": "3",
#                    "G": "4", "H": "4", "I": "4", "J": "5", "K": "5", "L": "5",
#                    "M": "6", "N": "6", "O": "6", "P": "7", "Q": "7", "R": "7",
#                    "S": "7", "T": "8", "U": "8", "V": "8", "W": "9", "X": "9",
#                    "Y": "9", "Z": "9"}, str(input("Введите номер: ")).split("-")
#
#
# def decryption(text: str) -> str:
#     _res = [code[i] for i in text]
#     _res = "".join(_res)
#     return _res
#
#
# if __name__ == '__main__':
#     res = [decryption(text=item) for item in number if item.isalpha()]
#     res.insert(0, number[0]) if len(res) < 3 else None
#     res = "-".join(res)
#     print(res)

# - 6 - Среднее количество слов. Среди исходного кода главы 8, а также в подпапке data "Решений задач по
# программированию" соответствующей главы вы найдете файл text.txt. В нем в каждой строке хранится одно предложение.
# Напишите программу, которая читает содержимое файла и вычисляет среднее количество слов в расчете на предложение.
# Решение:

# file = open('text.txt')
# lines = file.readlines()
# lis = []
# for i in lines:
#     i = i.split()
#     lis.append(len(i))
# print(f'Среднее количество слов в расчете на предложение: {sum(lis) / len(lis):.1f}')

# - 7 - Анализ символов. Напишите программу, которая читает содержимое файла и определяет:
#       • количество букв в файле в верхнем регистре;
#       • количество букв в файле в нижнем регистре;
#       • количество цифр в файле;
#       • количество пробельных символов в файле.
# Решение:

# with open('text.txt') as text:
#     list_1 = [i.strip() for i in text.readlines()]
#
#
# dct = {'count_lower': 0, 'count_upper': 0, 'count_space': 0, 'count_num': 0}
# string = (' '.join(list_1))
#
# for i in string:
#     if i.islower():
#         dct['count_lower'] += 1
#     elif i.isupper():
#         dct['count_upper'] += 1
#     elif i.isspace():
#         dct['count_space'] += 1
#     elif i.isdigit():
#         dct['count_num'] += 1
#
# print('Больших букв:', dct['count_upper'], '\n'
#       'Маленьких букв:', dct['count_lower'], '\n'
#       'Пробелов:', dct['count_space'], '\n'
#       'Цифр:', dct['count_num'], '\n')

# - 8 - Корректор предложений. Напишите программу с функцией, принимающей в качестве аргумента строковое значение
#       и возвращающей его копию, в котором первый символ каждого предложения написан в верхнем регистре. Например,
#       если аргументом является "привет! меня зовут джо. а как твое имя?", то эта функция должна вернуть строковое
#       значение 'Привет! Меня зовут Джо. А как твое имя?'. Программа должна предоставить пользователю возможность
#       ввести строковое значение и затем передать его в функцию. Модифицированное строковое значение должно быть
#       выведено на экран.
# Решение:
# def strouk(stroka):
#
#     return stroka.title()
#

# print(strouk(stroka=input(': ')))

# - 9 - Напишите программу с функцией, которая в качестве аргумента
#       принимает строковое значение и возвращает количество содержащихся в нем гласных.
#       Приложение должно иметь еще одну функцию, которая в качестве аргумента принимает
#       строковое значение и возвращает количество содержащихся в нем согласных. Приложение
#       должно предоставить пользователю возможность ввести строковое значение и показать
#       содержащееся в нем количество гласных и согласных.
# Решение 1:

# s = input(': ').lower()
# print('Количество гласных букв равно', sum(1 for _ in s if _ in 'ауоыиэяюёе'))
# print('Количество согласных букв равно', sum(1 for _ in s if _ in 'бвгджзйклмнпрстфхцчшщ'))

# Решение 2:
# def main(word):
#     count_glas, count_soglas = 0, 0
#     s = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z']
#     t = ['a', 'e', 'i', 'o', 'u', 'y']  # гласные
#     for q in list(word):
#         if q in s:
#             count_soglas += 1
#     for e in list(word):
#         if e in t:
#             count_glas += 1
#     return f'Гласных: {count_glas}\n' \
#            f'Согласных: {count_soglas}'
#
#
# print(main(word=input(': ').lower()))

# - 10 - Напишите программу, которая предоставляет пользователю возможность ввести строковое значение и выводит на
#        экран символ, который появляется в нем наиболее часто и связанное с ним число раз.
# Решение 1:
# string = input(': ').lower()
# a1, a2, a3 = 0, 0, 0
# for i in string:
#     if string.count(i) >= a2:
#         a2 = string.count(i)
#         a1 = i
#         a3 = string.count(a1)
#
# print(f'Чаще всего встречается символ - {a1}\n'
#       f'Он появляется: {a3} раз(а)')

# Решение 2:
# string = input(': ').lower()
# letters = [(letter, string.count(letter)) for letter in set(string)]
#
# print(max(letters, key=lambda x: x[1])[0])

# - 11 - Напишите программу, которая на входе принимает предложение, в котором все слова написаны без пробелов,
#        но первая буква каждого слова находится в верхнем регистре. Преобразуйте предложение в строковое значение,
#        в котором слова отделены пробелами, и только первое слово начинается с буквы в верхнем регистре. Например,
#        строковое значение "ОстановисьИПочувствуйЗапахРоз" будет преобразовано
#        в "Остановись и почувствуй запах роз".
# Решение:

# string = input(': ')
# spisok = []
# result = ''.join([' ' + x if x.isupper() else x for x in string]).split()
# for i in result:
#     spisok.append(i)
# print(' '.join(spisok).capitalize())


# - 12 - Напишите программу, которая на входе принимает предложение и преобразует каждое его слово в
#        "молодежный жаргон". В одной из его версий во время преобразования слова в молодежный жаргон первая
#        буква удаляется и ставится в конец слова. Затем в конец слова добавляется слог "ки". Вот пример.
#        Русский язык: ПРОСПАЛ ПОЧТИ ВСЮ НОЧЬ Молодежный жаргон: РОСПАЛПКИ ОЧТИПКИ СЮВКИ ОЧЬНКИ
# Решение:

# text = input(': ')
# print(' '.join(word[1:] + word[0] + 'ки' for word in text.split()))


# - 13 - Напишите одну или несколько программ, которые работают с файлом и показывают:
#   • 1О наиболее распространенных чисел, упорядоченных по частоте;
#   • 1О наименее распространенных чисел, упорядоченных по частоте;
#   • 10 наиболее "созревших" чисел (чисел, которые не использовались долгое время), упорядоченных от наиболее
#        созревших до наименее созревших;
#   • частоту каждого числа от 1 до 69 и частоту каждого PowerBall числа от 1 до 26.
# Пример чисел из файла:
# 17 22 36 37 52 24
# 14 22 52 54 59 04
# 05 08 29 37 38 34
# 10 14 30 40 51 01
# 07 08 19 26 36 15
# 13 27 37 41 54 32
# 04 17 35 50 57 12

# Решение НА 1О наиболее распространенных чисел, упорядоченных по частоте:

# # открыл файл
# with open('pbnumbers.txt') as text_1:
#
#     # залил его в список, удалил \n
#     spisok_1 = [num_1.strip() for num_1 in text_1]
#
# # разделил строки друг от друга что бы последние и первые числа не слиплялись
# s_1 = ' '.join(spisok_1).split()
#
# # конвертировал строковые елементы листа в int
# result_1 = [int(i_1) for i_1 in s_1]
# #
# counter_1 = {}
# # цикл по элементам объекта result_1
# for elem_1 in result_1:
#     #  если в словаре есть ключ в виде текущего элемента, "counter_1.get(elem_1, 0)"
#     #  вернет значение в словаре, которое лежит по этому ключу, иначе - 0. соответсна,
#     #  это вместо того, чтобы проверять, есть ли элемент в словаре
#     counter_1[elem_1] = counter_1.get(elem_1, 0) + 1
#     #  обычный list comprehension, но для словаря (element: count for - это ключ: значение)
# doubles_1 = {element: count for element, count in counter_1.items() if count > 1}
#
# # создал пустой словарь
# sorted_dict_2 = {}
#
# # отсортировал по ключу
# sorted_keys_2 = sorted(counter_1, key=counter_1.get)
#
# # написал цикл, и обрезал первые 22 элемента что бы получить 10 последних чисел
# for w in sorted_keys_2[22:]:
#
#     # добавил в пустой словарь отсортированные и обрезанные оставшиеся ключи
#     sorted_dict_2[w] = counter_1[w]
# print(f'10 наиболее распространенных чисел, упорядоченных по частоте:\n{sorted_dict_2}')

# Решение НА 1О наименее распространенных чисел, упорядоченных по частоте:

# # print('-' * 60)
# with open('pbnumbers.txt') as text_2:
#     spisok_2 = [num_2.strip() for num_2 in text_2]
# s_2 = ' '.join(spisok_2).split()
# result_2 = [int(i_2) for i_2 in s_2]
#
# counter_2 = {}
# for elem_2 in result_2:
#     counter_2[elem_2] = counter_2.get(elem_2, 0) + 1
# doubles_2 = {element: count for element, count in counter_2.items() if count > 1}
#
# sorted_dict_2 = {}
# sorted_keys_2 = sorted(counter_2, key=counter_2.get)
# for w in sorted_keys_2[:10]:
#     sorted_dict_2[w] = counter_2[w]
# print(f'10 наименее распространенных чисел, упорядоченных по частоте:\n{sorted_dict_2}')

# Решение на: частоту каждого PowerBall числа от 1 до 26.

# # print('-' * 60)
# with open('pbnumbers.txt') as text:
#     numbers = [int(number.strip()[-2::]) for number in text]
#
# counter = {}
# for elem in numbers:
#     counter[elem] = counter.get(elem, 0) + 1
# doubles = {element: count for element, count in counter.items() if count > 1}
#
# sorted_dict_3 = {}
# sorted_keys = sorted(counter, key=counter.get)
# for w in sorted_keys:
#     sorted_dict_3[w] = counter[w]
# print(f'Частота каждого числа PowerBall от 1 до 26:\n{sorted_dict_3}')

# Решение на: частоту каждого числа от 1 до 69

# print('-' * 60)
# with open('pbnumbers.txt') as text:
#     lst = [i.strip() for i in text.readlines()]
#     s = ' '.join(lst).split()
#     result = [int(i) for i in s]
#
# counter = {}
# for elem in result:
#     counter[elem] = counter.get(elem, 0) + 1
# doubles = {element: count for element, count in counter.items() if count > 1}
#
# sorted_dict = {}
# sorted_keys = sorted(counter, key=counter.get)
# for w in sorted_keys:
#     sorted_dict[w] = counter[w]
# print(f'Частота каждого числа от 1 до 69:\n{sorted_dict}')

# - 14 - В рамках этого задания необходимо написать одну или несколько программ, которые
#        считывают содержимое данного файла и выполняют приведенные ниже вычисления.
#   • Средняя цена за год: вычисляет среднюю цену бензина за год для каждого года в файле.
#   • Средняя цена за месяц: вычисляет среднюю цену в каждом месяце в файле.
#   • Наибольшая и наименьшая цены в году: в течение каждого года в файле определяет
#       дату и величину самой низкой и самой высокой цены.
#   • Список цен, упорядоченный по возрастанию: генерирует текстовый файл, в котором
#       даты и цены отсортирован в возрастающем порядке.
#   • Список цен, упорядоченный по увеличению: генерирует текстовый файл, в котором даты и цены отсортированы в
#       убывающем порядке.
#       Для выполнения всех этих вычислений можно написать одну программу или несколько
#       разных программ, одну для каждого вычисления.

# Решение:

# Решение на: Наибольшая и наименьшая цены в году: в течение каждого года в файле определяет
#             дату и величину самой низкой и самой высокой цены. #---ВОЗМОЖНО НЕОБХОДИМА ДОРОБОТКА---#

# with open('GasPrices.txt') as text:
#     numbers = [number.strip() for number in text]
# list_1 = [I1 for I1 in numbers[0:39]]
# dict_1 = {}
# for i in list_1:
#     key, value = i.split(':')
#     v = value.strip()
#     v = float(v) # if v.isdigit() else v
#     dict_1[key] = v
# print(f'Максимальная цена за 1993 год была {max(dict_1, key=dict_1.get)} числа, в цену {max(dict_1.values())}$\n'
#       f'Минимальная цена за 1993 год была {min(dict_1, key=dict_1.get)} числа, в цену {min(dict_1.values())}$')

# print('-' * 70)
# list_2 = [I2 for I2 in numbers[39:91]]
# dict_2 = {}
# for i in list_2:
#     key, value = i.split(':')
#     v = value.strip()
#     v = float(v) # if v.isdigit() else v
#     dict_2[key] = v
# print(f'Максимальная цена за 1994 год была {max(dict_2, key=dict_2.get)} числа, в цену {max(dict_2.values())}$ за галон\n'
#       f'Минимальная цена за 1994 год была {min(dict_2, key=dict_2.get)} числа, в цену {min(dict_2.values())}$ за галон')

# Решение на: Список цен, упорядоченный по возрастанию: генерирует текстовый файл, в котором
#             даты и цены отсортирован в возрастающем порядке.
# Этап 1 - вывод в словарь
# 1- открываем файл
# 2- считываем содержимое файлам одним списком строк
# 3- определяем выводной пустой словарь.
# 4- проходим в цикле по списку строк
# 5- присваиваем переменным key и value левую и правую часть подстроки, разделяя по символу ':'
# 6- убираем лишние концевые пробелы
# 7- определяем, является ли значение переменной v числом, и если да, то преобразуем к float числу
# 8- добавляем в словарь соответствующие пары ключ:значение

# Этап 2 - сортировка по возрастанию цен
# 1- При сортировке словаря мы можем передать еще один аргумент функции sorted()
#    следующим образом: sorted(res,.get)
# 2- Здесь key – это функция, которая вызывается для каждого элемента перед сравнением значений для сортировки.
# 3- Метод get() для объектов словаря возвращает значение for ключа словаря.
# 4- Выражение sorted(dict1,.get) вернет список ключей, значения которых отсортированы по порядку.
#    Оттуда мы можем создать новый, sorteddictionary:
# 5- Использование функции sorted() сократило объем кода, который нам приходилось писать при
#    использовании циклов for.
# 6- Однако мы можем далее объединить функцию sorted() с функцией itemgetter() для более краткого
#    решения задачи сортировки словарей по значениям.

# Этап 3 - запись в файл отсортированного словаря
# 1- Открыть файл для записи
# 2- создать цикл по ключам и значениям. Метод dict. items() возвращает новый список-представление
#    dict_items пар элементов словаря dict, такой, как (key, value) Другими словами возвращает список
#    кортежей вида (key, value) , состоящий из элементов словаря. Список-представление dict_items,
#    является динамичным объектом.

# with open('GasPrices.txt') as text:
#     new_file = text.readlines()
# res = {}
# for i in new_file:
#     key, value = i.split(':')
#     v = value.strip()
#     v = float(v)  # if v.isdigit() else v
#     res[key] = v

# sorted_dict = {}
# sorted_keys = sorted(res, key=res.get)
# for w in sorted_keys:
#     sorted_dict[w] = res[w]

# with open('out_1.txt', 'w') as out_1:
#     for key, val in sorted_dict.items():
#         out_1.write('{}:{}\n'.format(key, val))

# Решение на: генерирует текстовый файл, в котором даты и цены отсортированы в убывающем порядке.
# d = {k: sorted_dict[k] for k in sorted(sorted_dict, key=sorted_dict.get, reverse=True)}
# with open('out_2.txt', 'w') as out_2:
#     for key, val in d.items():
#         out_2.write('{}:{}\n'.format(key, val))
# print(d)
